{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"学习使用libxml2库","date":"2021-05-15T04:08:23.735Z","updated":"2021-05-15T04:08:23.735Z","comments":true,"path":"2021/05/15/学习使用libxml2库/","link":"","permalink":"http://example.com/2021/05/15/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8libxml2%E5%BA%93/","excerpt":"","text":"学习使用libxml2库背景由于之前一直使用json进行信息的配置和传输，不过这次由于项目需要，所以接触了一下XML，经过一些选择，最终决定用libxml2库，进行一下学习记录 libxml2库官方说明：http://www.xmlsoft.org/index.html XML结构xml结构图 图片来源于网上：https://youtu.be/KeLiQXqVgMI 该视频的截图","categories":[],"tags":[]},{"title":"","slug":"在mac上配置dpkg","date":"2021-05-15T04:08:23.735Z","updated":"2021-05-15T04:08:23.735Z","comments":true,"path":"2021/05/15/在mac上配置dpkg/","link":"","permalink":"http://example.com/2021/05/15/%E5%9C%A8mac%E4%B8%8A%E9%85%8D%E7%BD%AEdpkg/","excerpt":"","text":"在mac上配置dpkg背景在mac上安装dpkg，从网上找了一个安装教程，基本跟着教程走就顺利安装完成啦～ 安装教程链接：https://mrmad.com.tw/macos-dpkg-deb 根据教程走的时候，遇上的一些问题安装MacPorts卡住了，”正在运行软件包脚本”当在安装MacPort的时候卡住了很久的时候，可以先关闭正在安装的MacPort的进程，然后断开wifi，重新安装即可 1.关闭正在安装的MacPort的进程 在终端输入以下指令，查找MacPort安装进程的进程PID 1ps aux|grep install 查找MacPort安装进程 找到进程的PID以后，关掉它 1sudo kill PID进程号 关闭安装进程 2.关闭wifi 3.重新安装下载的MacPort的pkg安装包即可安装成功","categories":[],"tags":[]},{"title":"","slug":"树莓派配置基础环境-ssh-root-静态ip","date":"2021-05-15T04:08:23.735Z","updated":"2021-05-15T04:08:23.735Z","comments":true,"path":"2021/05/15/树莓派配置基础环境-ssh-root-静态ip/","link":"","permalink":"http://example.com/2021/05/15/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%85%8D%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83-ssh-root-%E9%9D%99%E6%80%81ip/","excerpt":"","text":"树莓派配置基础环境-ssh-root-静态ip配置root用户在终端进行如下操作即可：sudo passwd root然后根据提示输入root用户的密码再重复输入一次刚刚设置的密码 切换root用户操作如下即可：su -输入设置的root用户的密码 配置开启ssh操作如下即可：sudo vim /etc/ssh/sshd-config修改 PermitRootLogin yes然后保存修改然后执行sudo systemctl restart ssh再通过ss -tnl查看是否开启成功即可 配置静态ip如下在需要无线网络连接的情况下，配置eth0的静态ip如下：sudo vim /etc/network/interfaces然后再文件里增加以下内容auto loiface lo inet loopbackauto eth0iface eth0 inet staticaddress 192.168.0.1 //IP地址netmask 255.255.255.0 //掩码然后保存但是此时，如果不设置一下wlan0，那么会发现虽然静态ip设置成功了，但是树莓派却无法联网了所以还要在interfaces文件里追加以下内容auto wlan0iface wlan0 inet dhcpwpa_conf /etc/wpa_supplicant/wpa_supplicant.conf然后保存退出文件重启树莓派即可","categories":[],"tags":[]},{"title":"","slug":"虚拟机安装官方树莓派系统并配置交叉编译链","date":"2021-05-15T04:08:23.735Z","updated":"2021-05-15T04:08:23.735Z","comments":true,"path":"2021/05/15/虚拟机安装官方树莓派系统并配置交叉编译链/","link":"","permalink":"http://example.com/2021/05/15/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E5%AE%98%E6%96%B9%E6%A0%91%E8%8E%93%E6%B4%BE%E7%B3%BB%E7%BB%9F%E5%B9%B6%E9%85%8D%E7%BD%AE%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%93%BE/","excerpt":"","text":"虚拟机安装官方树莓派系统，配置交叉编译链1.下载官方镜像https://www.raspberrypi.org/software/raspberry-pi-desktop/通过官网，下载raspberry镜像64位系统iso文件之后，可以安装在虚拟机vbox/vmware里 2.下载交叉编译工具链通过github下载最新的官方树莓派交叉编译工具链git clone git://github.com/raspberrypi/tools.git 3.配置交叉编译工具链将arm-bcm2708文件夹拷贝到/opt/arm-bcm2708下（自定义路径即可） 将上面到交叉编译工具链的路径配置到~/.bashrc文件 12sudo vim ~/.bashrcexport PATH=$PATH:/opt/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin 4.测试交叉编译工具链是否安装成功输入以下指令，如果有打印一些版本信息，那么说明交叉编译环境配置正确arm-linux-gnueabihf-gcc -v如图: 5.假如第4步的时候有报错没有这个文件或目录，但实际是有这个文件的，可以apt-get安装libc6-dev-i386如果报错提醒如下： 可以按照以下的解决方案尝试一下： 然后重新输入arm-linux-gnueabihf-gcc -v即可发现打印版本信息 6.编写测试demo，然后编译生成执行文件demo略，编译的指令如下： 需要注意的是，该可运行文件不能在PC机上运行，只能在树莓派arm板子上运行 总结到此为止，虚拟机上的树莓派arm的交叉编译工具链搭建完成,这个官方的交叉编译工具链还是很靠谱的 参考资料下载镜像参考以下网址https://www.jianshu.com/p/1a65cb0b8f58下载安装交叉编译链参考以下网址https://www.cnblogs.com/zfyouxi/p/3831769.html","categories":[],"tags":[]},{"title":"","slug":"阅读paho.mqtt.c源码学习记录01","date":"2021-05-15T04:08:23.735Z","updated":"2021-05-15T04:08:23.735Z","comments":true,"path":"2021/05/15/阅读paho.mqtt.c源码学习记录01/","link":"","permalink":"http://example.com/2021/05/15/%E9%98%85%E8%AF%BBpaho.mqtt.c%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%9501/","excerpt":"","text":"阅读paho.mqtt.c源码学习记录01阅读paho.mqtt.c源码学习记录01MQTT协议是当前非常流行的一个工业物联网协议，它具有很多优势，比如：轻量，且对流量占有小的优势；基于订阅/发布模式；有心跳/遗言机智；通过qos控制消息接收质量等。 目前，基于MQTT协议封装的c的库，如下：https://github.com/eclipse/paho.mqtt.c 通过源码阅读，进行学习 1.版本管理在阅读MQTT源码库的时候，个人觉得，非常值得我自己写库的时候学习的经验，最简单的一点就是版本管理。 头文件里定义当前库的版本号；提供接口获取当前链接的库的版本号；通过版本比较，以此判断客户端程序使用库的时候，没有混淆不同的版本。 PS：这个设计真的很好，毕竟库的版本一直在迭代更新，如果没有一个版本管理，当编译时遇上了多个版本的同一个库，程序一旦链接了错误的版本，可能编译时可以成功编译，但是在运行时会出现各种奇奇怪怪得报错，而这种报错，往往非常难以排查。 2.注释合理MQTT源码库里的注释很详细，但是又不是那种对每一个函数、每一个参数、每一个返回值都进行长篇大论的累赘解释。MQTT源码库里的注释说明，其实是对重要接口的使用情景，注意事项（尤其是关于内存释放的提醒），以及接口设计的说明。 感觉这种注释风格，非常值得学习。毕竟很多注意事项，只有写代码的时候记得，等过上几个月再看，基本都忘的差不多了……对于后续维护来说，风格良好的注释真的重要。 3.接口的更新迭代都兼容了旧版本MQTT源码库也更新了这么久了，必然有接口的变更，新的接口取代旧的接口，不过从这份源码来看，对于新旧版本的兼容，处理的很值得学习。客户端程序几乎不用改动，就可以从使用旧的库，替换成新的库。这种设计对于库的使用者来说，是非常友好的。 总结以上是对于源码阅读最粗略的学习，更加具体的学习记录，将会在后续继续更新记录。","categories":[],"tags":[]},{"title":"","slug":"openvpn源码交叉编译","date":"2021-05-15T04:08:23.719Z","updated":"2021-05-15T04:08:23.719Z","comments":true,"path":"2021/05/15/openvpn源码交叉编译/","link":"","permalink":"http://example.com/2021/05/15/openvpn%E6%BA%90%E7%A0%81%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/","excerpt":"","text":"openvpn交叉编译需要源码交叉编译openvpn的操作步骤背景因为某些原因，只能选择交叉编译，当前平台是64位的，但是目标平台是32位的，目标平台又禁止了apt-get等相关操作，所以必须要源码交叉编译openvpn及其相关依赖库。因为之前交叉编译的时候，大多第三方库都是有现成的CMaKeLists.txt或者是Makefile，所以编译起来倒是也方便，但是，openvpn它只有configure文件，它是需要执行./configure成功设置好各种环境变量配置以后，才能生成Makefile的。于是，一开始踩了很多坑，在此做一个记录…… 一、预先配置的环境变量export CC=指定交叉编译时gcc编译版本export CXX=指定交叉编译时g++编译版本 二、编译openssl完整编译选项配置如下：setarch i386 ./config -m32 –prefix=/home/muhan/openssl/ –openssldir=/home/muhan/openssl/ -Wl,-rpath,/usr/local/openssl/lib shared详细选项含义如下：配置-m32 指定编译32位的库配置–prefix 指定openssl的安装目录配置–openssldir 指定openssl的目录配置shared关键字 指定编译时生成动态库（libssl.so/libcrypto.so及其相关软连接） 然后再make &amp;&amp; make install 即可 三、编译安装lzo完整编译选项配置如下：./configure –enable-shared –prefix=/home/muhan/lzo/usr –with-sysroot=指定交叉编译时的sysroot的路径名详细选项含义如下：配置–enable-shared 指定编译时生成动态库（liblzo2.so及其相关软连接）配置–prefix 指定lzo安装路径配置–with-sysroot 指定交叉编译时的sysroot 然后再make &amp;&amp; make install 即可 四、编译安装openvpn完整编译选项配置如下：./configure CC=指定交叉编译时gcc的那个版本 –prefix=/home/muhan/openvpn/ LZO_CFLAGS=”-I/home/muhan/lzo/usr/include” LZO_LIBS=”-L/home/muhan/lzo/usr/lib -llzo2” OPENSSL_CFLAGS=”-I/home/muhan/openssl/include” OPENSSL_LIBS=”-L/home/muhan/openssl/lib -lssl -lcrypto” –disable-plugin-auth-pam详细选项含义如下：配置CC的版本配置–prefix 指定openvpn安装目录配置LZO_CFLAGS 指定lzo的头文件路径配置LZO_LIBS 指定lzo的库文件路径及所链接的库配置OPENSSL_CFLAGS 指定openssl的头文件路径配置OPENSSL_LIBS 指定openssl的库文件路径及所链接的库配置–disable-plugin-auth-pam 禁掉pam模块 然后再make &amp;&amp; make install 即可 总结当编译第三方库的时候，如果没有CMakeLists.txt，也没有Makefile，只有config或者configure，那么需要先了解编译选项 执行./config –help 或者 ./configure –help 来查看当前支持的编译选项然后根据提示配置一下我们需要指定的选项，比如自己指定的openssl的版本的库和头文件路径名，比如CC的版本，比如安装路径等等(当然，如果不需要额外配置这些东西的话，直接走默认配置的话，那么直接执行./config 或者 ./configure 就行) 然后在生成Makefile之后，再make &amp;&amp; make install 即可","categories":[],"tags":[]},{"title":"","slug":"windows下使用Kernel32.lib库,统一API","date":"2021-05-15T04:08:23.719Z","updated":"2021-05-15T04:08:23.719Z","comments":true,"path":"2021/05/15/windows下使用Kernel32.lib库,统一API/","link":"","permalink":"http://example.com/2021/05/15/windows%E4%B8%8B%E4%BD%BF%E7%94%A8Kernel32.lib%E5%BA%93,%E7%BB%9F%E4%B8%80API/","excerpt":"","text":"windows下使用Kernel32.lib库,统一APIwindows下使用Kernel32.lib库,统一API背景由于是统一API的前提下，做成了不同实现了这些API功能的动态链接库，然后根据需要，动态的做出选择去加载这些动态库，并且是在windows下，所以最终用Kernel32.lib库 要注意接口导出头文件如下：（要注意将接口导出） 12345678910111213141516171819202122232425#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;//导出接口#ifdef DLLLIB #define DLLLIB _declspec(dllexport)#else#define DLLLIB _declspec(dllimport)#endifextern &quot;C&quot;&#123; DLLLIB short one_fun_api(const string&amp;); DLLLIB short two_fun_api(const int&amp;); DLLLIB short three_fun_api(const string&amp;); DLLLIB short four_fun_api(const string&amp;); DLLLIB bool five_fun_api(); DLLLIB bool six_fun_api();&#125; 主要代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556short loadLibDemo::realLoadLib(const string&amp; libPath)&#123; if(libPath.length() &lt;= 0) return -1; libHandle = LoadLibrary(libPath.c_str()); if(NULL==libHandle) &#123; printf(&quot;dlopen fail %s\\n&quot;, GetLastError()); return -1; &#125; pOne = (PFUN_APIOne)GetProcAddress(libHandle, &quot;one_fun_api&quot;); if(NULL == pOne) &#123; printf(&quot;[PFUN_APIOne] dlsym fail %s\\n&quot;, GetLastError()); return -1; &#125; pTwo = (PFUN_APITwo)GetProcAddress(libHandle, &quot;two_fun_api&quot;); if(NULL == pTwo) &#123; printf(&quot;[PFUN_APITwo] dlsym fail %s\\n&quot;, GetLastError()); return -1; &#125; pThree = (PFUN_APIThree)GetProcAddress(libHandle, &quot;three_fun_api&quot;); if(NULL == pThree) &#123; printf(&quot;[PFUN_APIThree] dlsym fail %s\\n&quot;, GetLastError()); return -1; &#125; pFour = (PFUN_APIFour)GetProcAddress(libHandle, &quot;four_fun_api&quot;); if(NULL == pFour) &#123; printf(&quot;[PFUN_APIFour] dlsym fail %s\\n&quot;, GetLastError()); return -1; &#125; pFive = (PFUN_APIFive)GetProcAddress(libHandle, &quot;five_fun_api&quot;); if(NULL == pFive) &#123; printf(&quot;[PFUN_APIFive] dlsym fail %s\\n&quot;, GetLastError()); return -1; &#125; pSix = (PFUN_APISix)GetProcAddress(libHandle, &quot;six_fun_api&quot;); if(NULL == pSix) &#123; printf(&quot;[PFUN_APISix] dlsym fail %s\\n&quot;, GetLastError()); return -1; &#125; return 0;&#125; 完整代码已经放在了https://github.com/TreeAndFlower/loadlibdemo-windows 注意点要记得导出API接口！ 123456如果没有导出接口，可能会报错，报错信息如下：GetProcAddress 出错，返回NULL(127)这个错误原因，就是由于忘记了没有导出dll库的对外接口函数，是忘记了用 extern &quot;C&quot; __declspec(dllexport) ，需要将接口导出，GetProcAddress才可以使用这些接口函数 windows下用Kernel32.lib库，头文件是Windows.h； PS： 另外，linux版本的blog在这里：https://treeandflower.github.io/2019/09/01/linux下使用dl库，统一API/ 如有描述不对之处，欢迎大家指正","categories":[],"tags":[]},{"title":"","slug":"windows下命令行查看进程号","date":"2021-05-15T04:08:23.719Z","updated":"2021-05-15T04:08:23.719Z","comments":true,"path":"2021/05/15/windows下命令行查看进程号/","link":"","permalink":"http://example.com/2021/05/15/windows%E4%B8%8B%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%8F%B7/","excerpt":"","text":"windows下命令行查看进程号windows下命令行查看进程号使用在windows下，知道某个执行程序的名称，比如ICO.exe想要查看它的进程id，比如电脑特别卡的时候，想知道它的进程id，然后关掉它 命令输入以下指令，可以查看当前所有的进程号 12//查看所有的进程号wmic process list 输入以下指令，可以查看某个被查询的执行程序的执行程序的名字，路径，以及进程号 12//输入以下指令，可以查看执行程序的名字，路径，以及进程号wmic process get name,executablepath,processid|findstr 执行程序名 输入以下指令，可以kill掉指定进程 12//强制杀死PID为processId的进程taskkill /pid processId -f 如下图，查看ICO.exe这个执行程序的路径，进程号： 总结windows下和linux下的命令查看方式不同，windows下查看进程号是用wmic process 命令；linux下直接用 ”pidof 执行程序名“","categories":[],"tags":[]},{"title":"","slug":"windows下查看dll库里编译的导出接口内容","date":"2021-05-15T04:08:23.719Z","updated":"2021-05-15T04:08:23.719Z","comments":true,"path":"2021/05/15/windows下查看dll库里编译的导出接口内容/","link":"","permalink":"http://example.com/2021/05/15/windows%E4%B8%8B%E6%9F%A5%E7%9C%8Bdll%E5%BA%93%E9%87%8C%E7%BC%96%E8%AF%91%E7%9A%84%E5%AF%BC%E5%87%BA%E6%8E%A5%E5%8F%A3%E5%86%85%E5%AE%B9/","excerpt":"","text":"windows下查看dll库里编译的导出接口内容windows下查看dll库里编译的导出接口内容背景之前在windows下，链接一个dll库的时候，报错的大概意思是说”xxx某个接口未定义”，于是就想着查看一下这个dll库，对外暴露的API到底是不是真的不存在，所以查找了一下，windows下，查看dll库编译的内容 查看dll库里编译的导出接口在安装了vs的前提下 输入win+r 然后cmd， 召唤出dos终端 找到vs安装目录下C:\\Program Files (x86)\\Microsoft Visual Studio 10.0\\Common7\\Tools，找到vsvar开头的一个bat文件，然后拖到dos终端（找到自己对应的vs安装目录下的，Tools工具路径下，找到vsvar开头的bat文件，然后拖拽到终端） 在dos终端下，输入dumpbin /exports dll库的绝对路径，即可查看dll库里，对外暴露的API的内容 大概效果如下： 参考资料解决方案：https://blog.csdn.net/z8110/article/details/89393549非常感谢hpuzsk在csdn的一篇blog里提供的解决方案，非常非常好用～ 讲解的非常仔细～对这个方案记录备份一下，免得之后忘记了～","categories":[],"tags":[]},{"title":"","slug":"windows下用VisualStudio编译libiconv库","date":"2021-05-15T04:08:23.719Z","updated":"2021-05-15T04:08:23.719Z","comments":true,"path":"2021/05/15/windows下用VisualStudio编译libiconv库/","link":"","permalink":"http://example.com/2021/05/15/windows%E4%B8%8B%E7%94%A8VisualStudio%E7%BC%96%E8%AF%91libiconv%E5%BA%93/","excerpt":"","text":"windows下用VisualStudio编译libiconv库windows下用VisualStudio编译libiconv库背景由于在linux下使用libiconv库进行gbk32与utf-8转码，在移植到windows平台的时候，发现系统里是没有libiconv库，所以从网上找了一些资源和教程，最终发现了一个很给力的解决办法，因此来记录一下备份一下 解决方案https://www.codeproject.com/Articles/302012/How-to-Build-libiconv-with-Microsoft-Visual-Studio 该链接libiconv的版本：1.14版本这个链接给出的解决方案很给力，大神给出了详细的修改源码的过程","categories":[],"tags":[]},{"title":"","slug":"关于交叉编译01","date":"2021-05-15T04:08:23.719Z","updated":"2021-05-15T04:08:23.719Z","comments":true,"path":"2021/05/15/关于交叉编译01/","link":"","permalink":"http://example.com/2021/05/15/%E5%85%B3%E4%BA%8E%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%9101/","excerpt":"","text":"关于交叉编译01在64位系统下交叉编译32位库背景有时候，会需要我们在原本的64位系统上，编译出32位系统上的库及可执行程序（如果我们不想去下载这个32位系统，或者说因为某些原因下载不到这个系统，就不能说直接简单的把自己的项目拷贝到32位系统上进行编译），那么这时候需要就是需要交叉编译来实现。 一般来说，交叉编译的核心，就是我们的项目依赖的gcc/g++的版本的不同，比如原本我们在64位系统上，系统默认的gcc/g++版本是4.9.0；但是现在我们希望移植到的平台，它的gcc/g++版本是5.3.0；那么我们首先要下载5.3.0版本的gcc/g++。 配置希望移植到的平台的gcc/g++版本接下来就是用我们指定的gcc/g++版本对我们要移植的项目进行编译，编译程序时需要指定：使用的gcc（可用户自定义路径名）:/usr/muhan/new/i686-gnu-gcc-5.3.0使用的g++（可用户自定义路径名）:/usr/muhan/new/i686-linux-gnu-g++同时需要指定编译时的sysroot为（可用户自定义路径名）:/usr/muhan/new/i686-linux-gnu/sysroot 可以通过以下命令设置 12export CC=/usr/muhan/new/i686-gnu-gcc-5.3.0export CXX=/usr/muhan/new/i686-linux-gnu-g++ 在编译第三方依赖库的过程中，一般有以下五种情况一、第三方程序里有CMakeLists.txt时（如libcurl）直接在CMakeLists.txt里增加以下3行 123set(CMAKE_CXX_FLAGS “-m32”)set(CMAKE_C_FLAGS “-m32”)SET(CMAKE_FINE_ROOT_PATH /usr/muhan/new/i686-linux-gnu/sysroot) 此时增加“-m32“选项是因为，我们要在64位系统下编译32位的库，所以要指定-m32选项 然后输入mkdir build &amp;&amp; cd build &amp; cmake .. &amp; make &amp; sudo make install 即可 二、如果没有CMakeLists.txt，但是有config文件（如openssl）1231. 输入setarch i386 ./config -m32 –prefix=/usr/muhan/ssl –openssldir=/usr/muhan/ssl -Wl,-rpath,/usr/local/ssl/lib shared2. 然后在make &amp;&amp; sudo make install 即可 三、如果没有CMakeLists.txt，也没有config文件，但是有configure文件（如libuuid)先执行./configure，会生成Makefile文件 然后修改Makefile, 增加m32选项 （参考链接https://blog.csdn.net/u013819292/article/details/53375731讲的非常仔细了) (1) 替换ld中的选项，/usr/bin/ld -m elf_x86_64修改为/usr/bin/ld -m elf_i386sed -i ‘s/elf_x86_64/elf_i386/g’ find . -name “Makefile” (2) 增加m32选项，使用32位gccsed -i ‘s/gcc/gcc -m32/g’ find . -name “Makefile” (3) 修改错误的替换sed -i ‘s/gcc -m323/gcc -m3/g’ find . -name “Makefile” 然后执行make &amp;&amp; sudo make install 即可 四、如果没有CMakeLists.txt，也没有config文件，也没有configure文件，但是有Makefile文件此时的处理方式和第三种情况一样，只是省了一个执行configure这个步骤来生成Makefile而已，剩下的步骤一样 五、如果没有CMakeLists.txt，也没有config文件，也没有configure文件，也没有Makefile文件，什么编译文件都没有给的情况下一般来说，这种情况非常少见，第三方库一般都会给出编译文件，如果真的碰上了什么编译文件都不给的，有可能是这个编译方式太简单了，直接用gcc/g++指令即可编译了,不过此时需要注意，要用我们指定的gcc/g++版本去编译！ 比如此时使用指令： /usr/muhan/new/i686-gnu-gcc-5.3.0 test.c来代替原本的： gcc test.c 也可以在这种情况下，自行编写CMakeLists.txt文件等其他编译文件，来编译这个项目，这个可以根据实际情况来自行调整。 交叉编译遇到问题时，排查的方向1.要注意当前编译的gcc、g++的版本，是不是我们指定的版本很可能忘记设置了某个编译选项，导致用了系统自带的gcc/g++版本进行编译，而不是我们希望移植到的那个平台的gcc/g++版本进行编译； 2.当前编译的程序，它所依赖的第三方的库，是不是也是同一个交叉编译工具链编译出来的32位的版本有可能忘记添加了-m32选项，从而导致在64位系统下默认编译出来64位的库，这一点我们可以用file指令或者objdump指令去检查一下我们生成的库文件的信息来进行确认；也有可能是用的旧的工具链编译出来的32位库，而不是用的交叉编译工具链编译出来的； 3.指定的头文件和库的路径是否正确如果我们发现，自己链接的库一句确认了是指定的gcc/g++版本编译出来的32位库，确认库的信息是正确的，但是项目中链接这个库的时候还是在报错，那么就需要去检查一下，项目里面设置的查找库的路径是否正确，也许项目现在还在链接系统原本的64位库，而不是我们新编译出来的32位库 总结在交叉编译的过程中，有时候会遇上一些零零碎碎的小问题，还是要具体情况具体分析，百度or谷歌是一个好习惯，很多问题一些大佬已经给解决了，可以从网上搜到现成的解决方案","categories":[],"tags":[]},{"title":"","slug":"关于本次博客搭建","date":"2021-05-15T04:08:23.719Z","updated":"2021-05-15T04:08:23.719Z","comments":true,"path":"2021/05/15/关于本次博客搭建/","link":"","permalink":"http://example.com/2021/05/15/%E5%85%B3%E4%BA%8E%E6%9C%AC%E6%AC%A1%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"关于本次博客搭建记录一下本次搭建blog的过程因为感觉有博客就很有意思的亚子，所以这两天趁着台风天也没法出去玩，索性捣腾一下个人博客的搭建好了，本次只是记录了我这次搭建blog参考的视频教程，因为CodeSheep这位大佬的视频讲的真的好，mac系统下跟着他的视频一步一步走，就很顺理成章的搭建完成了呢～ 本次mac搭建的时候，follow的视频教程视频链接：https://www.bilibili.com/video/av44544186/ 只是有一点需要注意的：需要用root用户进行一系列操作（一开始没有注意到，所以出来了一些报错信息，后来仔细一看，大佬用的是root用户进行的一系列操作） 剩下的就是follow大佬的视频，一步一步慢慢走，看完这个视频，就可以在mac环境下搭建自己的个人博客啦～ 在windows下搭建的时候，follow的网上的一个教程教程链接：https://zhuanlan.zhihu.com/p/26625249 因为还有一台windows的电脑，所以就也闲的无聊，就在windows上也搭建啦一下，其实和在mac上基本没有什么差别，只有2-3个极其个别的操作指令可能略有不同，不过follow这个教程一步步搭建，基本没有问题的～ 关于主题，follow的开源项目因为搭建了blog之后，就找了一些主题，看了一些之后，还是选择了用CodeSheep大佬推荐的yilia主题，再次也非常感谢litten分享的开源主题 主题链接：https://github.com/litten/hexo-theme-yilia 这套主题感觉也非常适合新手上手，操作非常友好，界面也很简洁，非常感谢大佬们的开源分享～ 记录本次是记录在搭建个人博客的时候，查找到的特别好的学习资料，非常的感谢大佬们在网上的分享～ 台风天的时候，我们家猫咪在我的电脑旁边睡的安稳，我看着各个教程，写着算是第一篇不注水的博客，感觉也别有一番意思～ blog里若有什么描述不当的bug，bug属于我，荣誉属于分享技术的大佬 睡觉毫无形象的小橘小橘同学，你这睡姿真的毫无形象呀～","categories":[],"tags":[]},{"title":"","slug":"单实例设计模式","date":"2021-05-15T04:08:23.719Z","updated":"2021-05-15T04:08:23.719Z","comments":true,"path":"2021/05/15/单实例设计模式/","link":"","permalink":"http://example.com/2021/05/15/%E5%8D%95%E5%AE%9E%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"单实例设计模式单实例设计模式应用场景单实例设计模式，是指让一个类只创建一个对象，为了保证这一点，将不会对外暴露new出来的接口对象，只提供一个实例供外部访问。 代码示例1234567891011121314151617181920212223class SignalModel&#123;public: static SignalModel* GetInstance(); static void DeleteInstance(); bool SayHello(); bool SayWorld(); bool AddNums(int a, int b); bool SubNums(int sum , int a);private: SignalModel();private: static SignalModel* sig; static pthread_mutex_t mutex;&#125;; 将SignalModel（）构造函数设为私有，可以阻止外部new出来实例；为了让外部可以访问类的public接口，所以类暴露出来一个访问自身的接口GetInstance（），并将其声明为静态成员函数； 完整代码完整代码已放在github上，地址：https://github.com/TreeAndFlower/singleModel.git 关于内存释放单实例模式声明了一个静态成员变量，那么，什么时候需要释放这个变量申请的空间呢？经过我自己目前经历的项目分析来看，是不需要释放，因为是静态对象，随着进程开始的时候被定义，然后当进程结束后，会自动释放空间；理论上，项目被设计为单例模式的时候，在进程没有结束以前，是不会希望释放这个实例空间的，所以不用特意纠结在哪里释放实例指针； 总结打算将自己学习到的设计模式一个个做个系统的总结，也算是自己的学习总结，这将会是一个系列，也是对我的知识体系的一个梳理过程，如有描述不当之处，还请大家指正。安利《大话设计模式》，讲解的非常有趣而且易懂","categories":[],"tags":[]},{"title":"","slug":"将linux下源码文件直接放在windows下vs编译的时候的报错","date":"2021-05-15T04:08:23.719Z","updated":"2021-05-15T04:08:23.719Z","comments":true,"path":"2021/05/15/将linux下源码文件直接放在windows下vs编译的时候的报错/","link":"","permalink":"http://example.com/2021/05/15/%E5%B0%86linux%E4%B8%8B%E6%BA%90%E7%A0%81%E6%96%87%E4%BB%B6%E7%9B%B4%E6%8E%A5%E6%94%BE%E5%9C%A8windows%E4%B8%8Bvs%E7%BC%96%E8%AF%91%E7%9A%84%E6%97%B6%E5%80%99%E7%9A%84%E6%8A%A5%E9%94%99/","excerpt":"","text":"将linux下源码文件，直接放在windows下vs编译的时候，关于undeclared identifier的奇怪报错将linux下源码文件，直接放在windows下vs编译的时候，关于undeclared identifier的奇怪报错背景我的一个工程里的源文件就叫他a.cpp,在linux下可以正常的编译，由于工程需要移植到windos下，所以我把a.cpp源文件移动到windows下的工程里，然后编译，编译的时候，发现有两个特别诡异的报错，报错内容如下： 更为奇怪的是，如果我在windows操作系统下，将a.cpp文件，用sublime.txt打开，然后再全选内容，拷贝到vs到工程里报错的a.cpp文件里，然后发现可以成功编译！ 原因经过一系列脑壳疼的排查，最终发现，这是因为，linux下和windows下的换行符不一样！！！如果用sublime.txt把报错的源文件a.cpp的所有\\n替换成windows下的\\r\\n,然后再保存文件，把保存修改的文件，挪到vs里直接编译，发现阔以了！！！ vs是不支持把linux下的换行符主动转成windows下的换行符的！！！巨坑 总结后来，查看了网友将linux和windows换行符的区别，讲的特别好链接：https://blog.csdn.net/stpeace/article/details/45767245 讲解的特别精彩的截图片段 吐槽不得不说，像换行符这种巨坑的问题，排查起来简直特别特别坑……","categories":[],"tags":[]},{"title":"","slug":"查看静态库-动态库-执行程序的编译工具链gcc-g++版本命令","date":"2021-05-15T04:08:23.719Z","updated":"2021-05-15T04:08:23.719Z","comments":true,"path":"2021/05/15/查看静态库-动态库-执行程序的编译工具链gcc-g++版本命令/","link":"","permalink":"http://example.com/2021/05/15/%E6%9F%A5%E7%9C%8B%E9%9D%99%E6%80%81%E5%BA%93-%E5%8A%A8%E6%80%81%E5%BA%93-%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BEgcc-g++%E7%89%88%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查看静态库-动态库-执行程序的编译工具链gcc-g++版本命令使用指令：objdump -s –section=.comment [库名或执行文件名] 如下图查看动态库：可以看出图里的libssl.so和libcrypto.so是交叉编译工具链编译出来的） 如下图查看静态库： 如下图查看执行文件：","categories":[],"tags":[]},{"title":"","slug":"树莓派64位系统配置32位运行环境","date":"2021-05-15T04:08:23.719Z","updated":"2021-05-15T04:08:23.719Z","comments":true,"path":"2021/05/15/树莓派64位系统配置32位运行环境/","link":"","permalink":"http://example.com/2021/05/15/%E6%A0%91%E8%8E%93%E6%B4%BE64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE32%E4%BD%8D%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/","excerpt":"","text":"树莓派64位系统配置32位运行环境配置libc6:armhf树莓派本身安装了64位系统的情况下，需要配置32位程序的运行环境，首先安装依赖库，操作步骤如下，以下操作都要在root用户下进行 配置32位程序的依赖库环境git clone git://github.com/raspberrypi/tools.git将arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/路径下的lib库都拷贝到/usr/local/lib32路径下，这个路径可以自己创建，自定义路径名，专门用来存放底层32位依赖库（如libstdc++.so.6) 总结其实最重要的，就是从官方提供的交叉编译工具链，把32位库给获取到，然后放到树莓派的自定义路径下，之后自己编译的32位执行程序/库，都要指定链接这个路径的基础库，否则会报错（找不到依赖库） 本身64位的树莓派系统是不带32位基础库的，所以必须从官方的交叉编译工具链里获取（目前，无法通过apt-get直接获取到所有的32位依赖库） 参考资料https://raspberrypi.club/148.html","categories":[],"tags":[]},{"title":"","slug":"树莓派交叉编译的三种常见方式","date":"2021-05-15T04:08:23.719Z","updated":"2021-05-15T04:08:23.719Z","comments":true,"path":"2021/05/15/树莓派交叉编译的三种常见方式/","link":"","permalink":"http://example.com/2021/05/15/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F/","excerpt":"","text":"树莓派交叉编译的三种常见方式","categories":[],"tags":[]},{"title":"","slug":"简单工厂模式学习笔记","date":"2021-05-15T04:08:23.719Z","updated":"2021-05-15T04:08:23.719Z","comments":true,"path":"2021/05/15/简单工厂模式学习笔记/","link":"","permalink":"http://example.com/2021/05/15/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"简单工厂模式学习笔记背景本次案例demo来自《大话设计模式》一书，是C++版本的实现 案例说明设计一个简单的计算器，可以进行加减乘除功能 源码完整源码已同步到github上地址：https://github.com/TreeAndFlower/sampleFactory.git 部分代码示例如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class baseCalculate&#123;public: baseCalculate(); ~baseCalculate(); virtual double getResult(double numA, double numB)=0;&#125;;class Add:public baseCalculate&#123;public: Add(); ~Add(); double getResult(double numA, double numB);&#125;;class Sub:public baseCalculate&#123;public: Sub(); ~Sub(); double getResult(double numA, double numB);&#125;;class Multi:public baseCalculate&#123;public: Multi(); ~Multi(); double getResult(double numA, double numB);&#125;;class Div:public baseCalculate&#123;public: Div(); ~Div(); double getResult(double numA, double numB);&#125;;class ExecuteCalculate&#123;public: ExecuteCalculate(); ~ExecuteCalculate(); bool calculateData(double numA, double numB, string strSign, double&amp; theValue); private: baseCalculate* the_base_cal;&#125;; 编译方式123cd buildcmake ..make 即可生成可执行文件sampleFactory，执行后即可看到如下效果： 特别说明在学习《大话设计模式》中，为了加深学习效果，因此用C++实现一遍文中的java案例，仅是学习笔记","categories":[],"tags":[]},{"title":"","slug":"ifconfig指令配置网卡信息","date":"2021-05-15T04:08:23.704Z","updated":"2021-05-15T04:08:23.704Z","comments":true,"path":"2021/05/15/ifconfig指令配置网卡信息/","link":"","permalink":"http://example.com/2021/05/15/ifconfig%E6%8C%87%E4%BB%A4%E9%85%8D%E7%BD%AE%E7%BD%91%E5%8D%A1%E4%BF%A1%E6%81%AF/","excerpt":"","text":"ifconfig指令配置网卡信息背景linux/unix系统下，输入ifconfig指令，发现只有lo本地回环，没有网卡信息，为了能够正常上网，需要配置一下网卡信息 当输入指令 12ifconfig eth0 192.168.1.100(可以自行设置ip地址） 会提示报错信息 12SIOCSIFADDR: No such deviceeth0: ERROR while getting interface flags: No such device 此时，我们会发现设置网卡eth0失败了，提示我们没有这个网卡。那么，很有可能，我们的网卡不叫“eth0”这个名字，而不是我们真的没有网卡。 ifconfig -a输入指令 1ifconfig -a 此时，我们可以看到系统列出来我们所有的网卡名，如下图： 配置网卡的ip接下来，我们发现自己系统的网卡果然没有eth0这个网卡名，但是有en0，所以，接下来我们设置来配置这个网卡的ip 12ifconfig en0 192.168.1.100(可以自行设置ip地址） 然后回车后，就发现设置ip成功啦～ 总结一般情况下，因为我们常见的linux下的网卡名字都是eth0，所以习惯性的就直接配置eth0的ip，但是有的系统并不是用eth0当网卡名，所以还是要先输入ifconfig -a指令，来查看一下我们当前的系统下，网卡的名字都是什么，然后再去配置ip","categories":[],"tags":[]},{"title":"","slug":"debian10系统原本为64位系统下如何配置32位编译and运行环境","date":"2021-05-15T04:08:23.704Z","updated":"2021-05-15T04:08:23.704Z","comments":true,"path":"2021/05/15/debian10系统原本为64位系统下如何配置32位编译and运行环境/","link":"","permalink":"http://example.com/2021/05/15/debian10%E7%B3%BB%E7%BB%9F%E5%8E%9F%E6%9C%AC%E4%B8%BA64%E4%BD%8D%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE32%E4%BD%8D%E7%BC%96%E8%AF%91and%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/","excerpt":"","text":"debian10系统原本为64位系统，如何配置32位编译and运行环境背景原本安装的是debian10的64位系统，但是因为有些第三方程序是32位的，需要在这个系统上编译运行，那么需要配置一下必要的环境 当32位程序放在debian64位系统里无法编译or运行时，如何判断是因为没有配置32位编译or运行环境一般来说，编译32位程序时，如果出现以下报错,可以认为没有配置32位编译or运行环境 1fatal error: bits/libc-header-start.h: No such file or directory 运行32位程序时，如果出现以下报错，也可以认为没有配置32位编译or运行环境 123//明明有执行程序test（32位的），但是执行./test的时候却报错test： no such file or directory 出现以上两种情况的任何一个时，一般可以判断时由于64位debian系统下，没有配置32位程序的编译or运行环境，需要执行以下两个步骤 解决方案一、执行sudo apt-get install gcc-multilib安装gcc-multilib 12//安装gcc-multilibsudo apt-get install gcc-multilib 二、执行sudo apt-get install g++-multilib安装g++-multilib 12//安装g++-multilibsudo apt-get install g++-multilib 总结因为从官网直接下载下来的debian10的64位安装镜像在安装完成后，原始的debian系统是不支持32位程序运行的，所以需要对环境进行配置，所以做个记录，免得下次忘记了","categories":[],"tags":[]},{"title":"","slug":"linux下使用dl库统一API","date":"2021-05-15T04:08:23.704Z","updated":"2021-05-15T04:08:23.704Z","comments":true,"path":"2021/05/15/linux下使用dl库统一API/","link":"","permalink":"http://example.com/2021/05/15/linux%E4%B8%8B%E4%BD%BF%E7%94%A8dl%E5%BA%93%E7%BB%9F%E4%B8%80API/","excerpt":"","text":"linux下使用dl库，统一APIlinux下使用dl库，统一API背景由于是统一API的前提下，做成了不同实现了这些API功能的动态链接库，然后根据配置文件等，动态的做出选择去加载这些动态库，并且是在linux下，所以最终选择了dl库 主要代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//需要#include &lt;dlfcn.h&gt;short loadLibDemo::realLoadLib(const string&amp; libPath)&#123; if(libPath.length() &lt;= 0) return -1; libHandle = dlopen(libPath.c_str(), RTLD_GLOBAL | RTLD_NOW); if(NULL==libHandle) &#123; printf(&quot;dlopen fail %s\\n&quot;,dlerror()); return -1; &#125; pOne = (PFUN_APIOne)dlsym(libHandle, &quot;one_fun_api&quot;); if(NULL == pOne) &#123; printf(&quot;[PFUN_APIOne] dlsym fail %s\\n&quot;,dlerror()); return -1; &#125; pTwo = (PFUN_APITwo)dlsym(libHandle, &quot;two_fun_api&quot;); if(NULL == pTwo) &#123; printf(&quot;[PFUN_APITwo] dlsym fail %s\\n&quot;,dlerror()); return -1; &#125; pThree = (PFUN_APIThree)dlsym(libHandle, &quot;three_fun_api&quot;); if(NULL == pThree) &#123; printf(&quot;[PFUN_APIThree] dlsym fail %s\\n&quot;,dlerror()); return -1; &#125; pFour = (PFUN_APIFour)dlsym(libHandle, &quot;four_fun_api&quot;); if(NULL == pFour) &#123; printf(&quot;[PFUN_APIFour] dlsym fail %s\\n&quot;,dlerror()); return -1; &#125; pFive = (PFUN_APIFive)dlsym(libHandle, &quot;five_fun_api&quot;); if(NULL == pFive) &#123; printf(&quot;[PFUN_APIFive] dlsym fail %s\\n&quot;,dlerror()); return -1; &#125; pSix = (PFUN_APISix)dlsym(libHandle, &quot;six_fun_api&quot;); if(NULL == pSix) &#123; printf(&quot;[PFUN_APISix] dlsym fail %s\\n&quot;,dlerror()); return -1; &#125; return 0;&#125; 完整代码已经放在了https://github.com/TreeAndFlower/loadlibdemo-linux 注意点主要是，要对导出的动态库里的API，记得“extern c” 当没有extern c的时候，编译出来的动态库里API如下： 当extern c添加了以后，编译出来的动态库API如下： 另外需要注意的是 这个示例代码，仅在linux平台下生效，因为链接的dl库，头文件是#include &lt;dlfcn.h&gt;，这些是linux平台的；windows下用Kernel32.lib库，头文件是Windows.h； PS：windows下的实现，博客链接为https://treeandflower.github.io/2019/09/09/windows下使用Kernel32-lib库-统一API/ 如有描述不对之处，欢迎大家指正","categories":[],"tags":[]},{"title":"","slug":"libcurl交叉编译","date":"2021-05-15T04:08:23.704Z","updated":"2021-05-15T04:08:23.704Z","comments":true,"path":"2021/05/15/libcurl交叉编译/","link":"","permalink":"http://example.com/2021/05/15/libcurl%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/","excerpt":"","text":"libcurl交叉编译需要源码交叉编译libcurl操作步骤背景有时候需要交叉编译libcurl，比如目标机器是32位系统的，但是本地机器是64位系统的，而且由于某些原因，我们无法在32位系统上直接编译，所以需要用到交叉编译 编译openssllibcurl是依赖openssl的，所以先编译openssl的32位库 完整编译选项配置如下：setarch i386 ./config -m32 –prefix=/home/muhan/openssl/ –openssldir=/home/muhan/openssl/ -Wl,-rpath,/usr/local/openssl/lib shared详细选项含义如下：预先已经export CC的版本配置-m32 指定编译32位的库配置–prefix 指定openssl的安装目录配置–openssldir 指定openssl的头文件目录配置shared关键字 指定编译时生成动态库（libssl.so/libcrypto.so及其相关软连接） 然后再make &amp;&amp; make install 即可 编译安装zlib有时候有的系统是默认安装了32位zlib库的，那么就可以跳过这一步，但是有的系统需要自己下载编译zlib-32位库 完整编译选项配置如下：直接修改CMakeLists.txt文件，增加以下两行set(CMAKE_C_FLAGS “-m32”)set(CMAKE_CXX_FLAGS “-m32”)详细选项含义如下：配置CMAKE_C_FLAGS 指定编译32位库环境配置CMAKE_CXX_FLAGS 指定编译32位库环境 然后再mkdir build &amp;&amp; cd build &amp;&amp; cmake .. &amp;&amp; make &amp;&amp; make install 即可 编译安装libcurl最后就是编译libcurl 完整编译选项配置如下：./configure PKG_CONFIG_PATH=/home/muhan/openssl CFLAGS=”-m32” CPPFLAGS=”-I/home/muhan/openssl/include” LDFLAGS=”-L/home/muhan/openssl/lib”详细选项含义如下：配置PKG_CONFIG_PATH 指定启动openssl选项(启动这个选项，就会默认链接lssl，lcrypto，lz三个库）配置CFLAGS 指定编译32位库环境配置CPPFLAGS 指定链接的库的头文件配置LDFLAGS 指定链接的库的路径 然后再make &amp;&amp; make install 即可 总结当编译第三方库的时候，如果有CMakeLists.txt，直接用CMakeLists.txt编译就很方便；如果只有configure，那么需要先了解编译选项 执行./configure –help 来查看当前支持的编译选项然后根据提示配置一下我们需要指定的选项，比如自己指定的openssl的版本的库和头文件路径名，比如CC的版本，比如安装路径等等(当然，如果不需要额外配置这些东西的话，直接走默认配置的话，那么直接执行./config 或者 ./configure 就行) 然后在生成Makefile之后，再make &amp;&amp; make install 即可","categories":[],"tags":[]},{"title":"","slug":"linux下使用nm指令查看静态库or动态库编译内容","date":"2021-05-15T04:08:23.704Z","updated":"2021-05-15T04:08:23.704Z","comments":true,"path":"2021/05/15/linux下使用nm指令查看静态库or动态库编译内容/","link":"","permalink":"http://example.com/2021/05/15/linux%E4%B8%8B%E4%BD%BF%E7%94%A8nm%E6%8C%87%E4%BB%A4%E6%9F%A5%E7%9C%8B%E9%9D%99%E6%80%81%E5%BA%93or%E5%8A%A8%E6%80%81%E5%BA%93%E7%BC%96%E8%AF%91%E5%86%85%E5%AE%B9/","excerpt":"","text":"linux下使用nm指令查看静态库/动态库编译内容在linux下使用nm指令查看静态库/动态库编译内容背景之前其实没有关注过，库里面到底是哪些内容，然而最近遇上了一个链接库的问题，然后关注了一下这个问题，查到使用nm指令，即可查看到linux下，静态库，动态库里到底编译了哪些内容 使用nm指令查看静态库编译的内容指令格式为： 12//查看静态库编译内容nm 静态库名称 效果大概如下图所示： 查看静态库编译内容 可以看到编译的变量和函数接口 使用nm指令查看动态库编译的内容指令格式为： 12//查看动态库编译内容nm 动态库名称 效果大概如下图： 查看动态库编译内容 记录虽然大部分时间里，我并不需要知道库里面到底编译了什么内容，但是有时候在链接第三方库的时候，在排查相关bug的时候，知道库里面到底编译了什么，还是很有帮助的，因此做个记录","categories":[],"tags":[]},{"title":"","slug":"linux下安装tcpdump并用其抓包","date":"2021-05-15T04:08:23.704Z","updated":"2021-05-15T04:08:23.704Z","comments":true,"path":"2021/05/15/linux下安装tcpdump并用其抓包/","link":"","permalink":"http://example.com/2021/05/15/linux%E4%B8%8B%E5%AE%89%E8%A3%85tcpdump%E5%B9%B6%E7%94%A8%E5%85%B6%E6%8A%93%E5%8C%85/","excerpt":"","text":"linux下安装tcpdump并用其抓包背景有时候需要分析网络协议，这时候抓包看看直接的数据，能够有助于对协议有一个直观的感受，在windows下，可以直接安装Wireshark就能轻松抓包分析了，但是在linux下，没有Wireshark，所以可以安装tcpdump，用tcpdump抓包分析 安装tcpdump安装tcpdump有两种方式，一种是下载tcpdump源码，然后编译安装；另一种是直接用系统安装命令 下载源码安装tcpdump这个可以参考：https://blog.csdn.net/tic_yx/article/details/17012317这篇文章里记录的很详细文章内容截图如下： 直接用系统安装命令在ubuntu下，可以直接使用sudo apt-get install tcpdump如果这一步安装的时候有报错，可以更新一下下载源，国内清华的下载源还是很好用的 用tcpdump抓包sudo tcpdump -i 网卡 -entXX 也可以把tcpdump抓到的数据保存到文件里sudo tcpdump -i 网卡 -entXX -w 文件名.pcap然后将pcap文件从linux里拷贝到windows下，用Wireshark分析数据","categories":[],"tags":[]},{"title":"","slug":"linux下查看编译的静态库和动态库是32位还是64位","date":"2021-05-15T04:08:23.704Z","updated":"2021-05-15T04:08:23.704Z","comments":true,"path":"2021/05/15/linux下查看编译的静态库和动态库是32位还是64位/","link":"","permalink":"http://example.com/2021/05/15/linux%E4%B8%8B%E6%9F%A5%E7%9C%8B%E7%BC%96%E8%AF%91%E7%9A%84%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E6%98%AF32%E4%BD%8D%E8%BF%98%E6%98%AF64%E4%BD%8D/","excerpt":"","text":"linux下查看编译的静态库和动态库是32位还是64位linux下查看编译的静态库和动态库是32位还是64位有时候可能会需要交叉编译，所以需要知道平台上编译出来的版本到底是64位还是32位 file指令查看动态库是32位还是64位如图：file libcurl.so 查看当前编译的libcurl.so是32位还是64位的 objdump -a指令查看静态库是32位还是64位的如图：objdump -a libtest.a 查看当前编译的静态库libtest.a是32位还是64位的 readelf -h指令查看静态库or动态库是32位or64位，及编译平台运行平台等信息如图：readelf -h libssl.so 查看编译的动态库lib","categories":[],"tags":[]},{"title":"","slug":"mac下配置rar与unrar命令","date":"2021-05-15T04:08:23.704Z","updated":"2021-05-15T04:08:23.704Z","comments":true,"path":"2021/05/15/mac下配置rar与unrar命令/","link":"","permalink":"http://example.com/2021/05/15/mac%E4%B8%8B%E9%85%8D%E7%BD%AErar%E4%B8%8Eunrar%E5%91%BD%E4%BB%A4/","excerpt":"","text":"mac下配置rar与unrar命令背景因为在mac下下载了rar文件，需要解压，然而mac上默认没有rar解压环境，于是配置了一下命令行rar/unrar环境 环境配置1.下载RAR包1234//下载地址如下https://www.rarlab.com/download.htm//然后选择for macOS的更新包，比如RAR 5.91 beta 1 for macOS(64 bit) 2.解压下载后的更新包12//找到刚刚的更新包路径，然后cd到这个路径下，在命令行输入tar -zxvf rarosx-5.9.1b1.tar 3.安装rar和unrar12sudo install -c -o $USER rar /usr/local/binsudo install -c -o $USER unrar /usr/local/bin 4.然后需要在安全与隐私里准许这个rar软件包如下图所示，先点击解锁，然后输入密码，然后准许rar软件包（因为我这边已经准许过了，所以这里现在是空，差不多就是这个位置） 5.然后就可以解压自己的rar文件了1234//解压unrar x test.rar//压缩rar a test.rar test/ 总结不得不说，mac下的安全管理还是严格的","categories":[],"tags":[]},{"title":"","slug":"map存放函数指针","date":"2021-05-15T04:08:23.704Z","updated":"2021-05-15T04:08:23.704Z","comments":true,"path":"2021/05/15/map存放函数指针/","link":"","permalink":"http://example.com/2021/05/15/map%E5%AD%98%E6%94%BE%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/","excerpt":"","text":"map存放函数指针map里存放函数指针由于有时候，想把某一类功能的函数，存在一个map里，所以写了一个demo 代码源码如下（已本地运行通过）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//// main.cpp// mapfunc//// Created by 慕寒 on 2019/9/22.// Copyright © 2019 慕寒. All rights reserved.//// 将函数指针缓存在map里#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;void* helloFuncOne()&#123; cout &lt;&lt; &quot;Hello, World!\\n&quot;; return NULL;&#125;long helloFuncTwo(long x, long y)&#123; long ret = 0; ret = x + y; cout &lt;&lt; &quot;x + y = &quot;&lt;&lt; ret &lt;&lt;endl; return ret;&#125;int main(int argc, const char * argv[]) &#123; // 缓存函数名，函数指针在map里 map&lt;string, long&gt; func_name_ptr; //将函数指针缓存到map里 func_name_ptr[&quot;func1&quot;] = (long)&amp;helloFuncOne; func_name_ptr[&quot;func2&quot;] = (long)&amp;helloFuncTwo; //调用函数指针func1 typedef void* (*FUNC)(); long fptr_one = func_name_ptr[&quot;func1&quot;]; if(fptr_one != 0) &#123; cout &lt;&lt; &quot;fptr_one \\n&quot;; //调用函数func1 ((FUNC)fptr_one)(); &#125; //调用函数指针func2 typedef long (*FUNCTWO)(long, long); long fptr_two = func_name_ptr[&quot;func2&quot;]; if(fptr_two != 0) &#123; cout &lt;&lt; &quot;fptr_two \\n&quot;; //调用函数func2 long two_ret = ((FUNCTWO)fptr_two)(3, 7); cout &lt;&lt; &quot;two_ret = &quot;&lt;&lt;two_ret &lt;&lt;endl; &#125; return 0;&#125; //PS: map的第二个参数为什么用了long型，而不是int型//由于在XCode编译报错 Cast from pointer to smaller type ‘int’ loses information//报错原因是：由于使用了强转将void转为int，而在XCode上使用的为x64的编译，X64下的void地址为8字节，而int为4字节，强转时会导致越界，故出现此错误。源码运行后到结果如下： 总结注意类型强制转换到时候，可能会有越界报错 源码已同步到github上：https://github.com/TreeAndFlower/map_func_ptr","categories":[],"tags":[]},{"title":"","slug":"mqtt连接时报错-8","date":"2021-05-15T04:08:23.704Z","updated":"2021-05-15T04:08:23.704Z","comments":true,"path":"2021/05/15/mqtt连接时报错-8/","link":"","permalink":"http://example.com/2021/05/15/mqtt%E8%BF%9E%E6%8E%A5%E6%97%B6%E6%8A%A5%E9%94%99-8/","excerpt":"","text":"mqtt连接时报错-8mqtt连接时报错，错误码是-8背景使用mqtt-c库，创建mqtt连接的时候报错，错误码是-8 问题排查根据头文件来看 1#define MQTTASYNC_BAD_STRUCTURE -8 错误码是-8的时候，表示创建连接的mqtt的结构体是错误的 经过排查之后，发现，是mqtt的库版本不对。因为系统里同时安装了两个版本的mqtt的库，一个是最新的，一个是原本用的旧版本的，在编译的时候，用了最新的mqtt的版本编译。 但是把程序给别人的时候，别人用的是旧版本的mqtt的动态库，所以当程序执行的时候，当创建连接时，会报错-8 总结在多个人使用同一个第三方库的时候，一定一定要注意，版本的问题；要保证大家使用的是统一的版本号编译的第三方动态库！ 版本差异导致报错，这种问题真的很坑……","categories":[],"tags":[]},{"title":"","slug":"centos或mac下使用locate指令时报错","date":"2021-05-15T04:08:23.688Z","updated":"2021-05-15T04:08:23.688Z","comments":true,"path":"2021/05/15/centos或mac下使用locate指令时报错/","link":"","permalink":"http://example.com/2021/05/15/centos%E6%88%96mac%E4%B8%8B%E4%BD%BF%E7%94%A8locate%E6%8C%87%E4%BB%A4%E6%97%B6%E6%8A%A5%E9%94%99/","excerpt":"","text":"centos或mac下使用locate指令时，报错(/var/db/locate.database)centos或mac下使用locate指令时，出现报错信息The locate database (/var/db/locate.database) 在centos系统下，使用locate指令报错使用locate指令时，出现报错信息’var/lib/mlocate/mlocate.db’:No such file or directory时，处理方案如下： 123//输入以下指令即可updatedb//需要等待一段时间，因为生成数据库需要一段时间 稍等一段时间之后，再输入locate指令，即可发现可以使用了 在mac系统下，使用locate指令报错当在mac上使用locate指令时，报错如下： 解决方案如下： 先根据刚才的提醒，输入sudo launchctl load -w /System/Library/LaunchDaemons/com.apple.locate.plist 然后，输入指令sudo /usr/libexec/locate.updatedb 输入上面这个指令后，会等待好久一段时间，要稍微等待一会儿 最后再次输入locate指令，发现locate指令已经生效啦 参考资料因为我之前经常在ubuntu下，都没有碰到过locate指令不好用的情况，最近需要在centos和mac下操作，忽然发现居然loacte指令使用失效，于是上网查找了解决办法，经过尝试了一些方案后，终于在centos和mac下可以使用locate指令了，因此做出了以上的总结～ 感谢网友们无私分享的解决方案～参考的网友方案：https://www.jianshu.com/p/d8f4f9e4b58c","categories":[],"tags":[]},{"title":"","slug":"CMakeLists.txt学习记录1","date":"2021-05-15T04:08:23.688Z","updated":"2021-05-15T04:08:23.688Z","comments":true,"path":"2021/05/15/CMakeLists.txt学习记录1/","link":"","permalink":"http://example.com/2021/05/15/CMakeLists.txt%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951/","excerpt":"","text":"CMakeLists.txt学习记录（一）CMakeLists.txt 学习参考资料来自于官方：https://cmake.org/cmake-tutorial/ 官方代码如下：12345678910111213141516171819202122232425//官方demo，求一个数的开方//tutorial.xxx// A simple program that computes the square root of a number#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &quot;TutorialConfig.h&quot; int main (int argc, char *argv[])&#123; if (argc &lt; 2) &#123; fprintf(stdout,&quot;%s Version %d.%d\\n&quot;, argv[0], Tutorial_VERSION_MAJOR, Tutorial_VERSION_MINOR); fprintf(stdout,&quot;Usage: %s number\\n&quot;,argv[0]); return 1; &#125; double inputValue = atof(argv[1]); double outputValue = sqrt(inputValue); fprintf(stdout,&quot;The square root of %g is %g\\n&quot;, inputValue, outputValue); return 0;&#125; 对于这个demo，我们如果想通过写CMakeLists.txt文件来编译它，并且，想要给这个执行文件加上版本信息，可以通过以下的选项设置 1. 增加版本信息的配置文件TutorialConfig.h.in内容如下： 12345//TutorialConfig.h.in//官方源码如下：// the configured options and settings for Tutorial#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@ 2. 根据tutorial.cxx指定的头文件TutorialConfig.h来看，我们要将生成的配置信息保存在这个头文件里，我们可以利用CMakeLists.txt给我们生成这个文件3. 以下是CMakeLists.txt的内容123456789101112131415161718192021//CMakeLists.txt//官方内容如下：cmake_minimum_required (VERSION 2.6)project (Tutorial)# The version number.set (Tutorial_VERSION_MAJOR 1)set (Tutorial_VERSION_MINOR 0) # configure a header file to pass some of the CMake settings# to the source codeconfigure_file ( &quot;$&#123;PROJECT_SOURCE_DIR&#125;/TutorialConfig.h.in&quot; &quot;$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h&quot; ) # add the binary tree to the search path for include files# so that we will find TutorialConfig.hinclude_directories(&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;) # add the executableadd_executable(Tutorial tutorial.cxx) 4.接下来是跑一下官方的demo根据官方教程搭建下来，目前，目录结构应该是这样的 然后cmake .编译一下，通过CMakeLists.txt生成TutorialConfig.h等后续依赖文件出来 浏览一下目录结构，可以看下，此时，目录结构应该是这样的 开始make编译出最终生成的执行文件 执行一下，可以看版本信息 带参数的执行，可以看到，程序可以输出用户指定的数据的开方 由此，跟着官方走了一遍流程，实现了可以通过CMakeLists.txt指定程序的版本信息的程序以上是本次follow官方demo的学习过程（一）","categories":[],"tags":[]},{"title":"","slug":"cjson库版本不一致，导致解析失败","date":"2021-05-15T04:08:23.688Z","updated":"2021-05-15T04:08:23.688Z","comments":true,"path":"2021/05/15/cjson库版本不一致，导致解析失败/","link":"","permalink":"http://example.com/2021/05/15/cjson%E5%BA%93%E7%89%88%E6%9C%AC%E4%B8%8D%E4%B8%80%E8%87%B4%EF%BC%8C%E5%AF%BC%E8%87%B4%E8%A7%A3%E6%9E%90%E5%A4%B1%E8%B4%A5/","excerpt":"","text":"cjson库版本不一致，导致解析失败cjson库版本不一致，导致解析失败现象在编译一个程序demo的时候，需要继承一个第三方库libexample.so，第三方库用到了cjson，本身这个程序也用到了cjson，由于两者用的cjson的版本不一致，导致json解析失败…… 旧版本cjson第三方库libexample.so使用的旧版本的cjson，cjson-types截图如下： 新版本cjson程序demo使用的是新版本的cjson，cjson-types截图如下： 具体现象用旧版本的cJSON源码编译到自己的代码里，编译出libexample.so库；程序demo已经使用过新版本的cJSON源码，但是又连接了上面编译出来的libexample.so的库，再次进行json解析，会发现libexample.so里面解析cJSON_Number类型的节点的值会失败；然后重新用新版本的cJSON源码编译出libexample.so库，再集成到上面的demo里面，即可解析成功。 分析可以从上面两个不同版本的cjson源码截图的cjosn-types看出来：这两个版本的cJSON Types的值不一样，比如cJSON_Number类型节点的值，旧版本的值是3， 新版本的值是8，所以用旧版本编译的libexample.so库，集成到demo里的时候，解析到cJSON_Number节点的时候，错误的使用值8而不是3，所以导致解析失败 结论代码里一定要保持一个版本的cjson；版本混乱很容易造成奇怪的问题，而且这种问题往往还不容易排查！","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-05-15T04:08:23.688Z","updated":"2021-05-15T04:08:23.688Z","comments":true,"path":"2021/05/15/hello-world/","link":"","permalink":"http://example.com/2021/05/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"开发clickMouse鼠标点击小工具删除邮箱里的2w多垃圾邮件","slug":"开发clickMouse鼠标点击小工具删除邮箱里的2w多垃圾邮件","date":"2021-05-15T03:21:39.000Z","updated":"2021-05-15T04:08:23.735Z","comments":true,"path":"2021/05/15/开发clickMouse鼠标点击小工具删除邮箱里的2w多垃圾邮件/","link":"","permalink":"http://example.com/2021/05/15/%E5%BC%80%E5%8F%91clickMouse%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%88%A0%E9%99%A4%E9%82%AE%E7%AE%B1%E9%87%8C%E7%9A%842w%E5%A4%9A%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6/","excerpt":"","text":"hello-world","categories":[],"tags":[]}],"categories":[],"tags":[]}